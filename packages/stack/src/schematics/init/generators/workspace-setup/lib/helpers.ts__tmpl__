import { bold, gray, inverse, magentaBright } from 'chalk'
import { execSync } from 'child_process'
import { existsSync, readFileSync, writeFileSync } from 'fs'
import { basename } from 'path'
import { Client } from 'pg'

export const MAX_RETRIES = 30
export const WORKSPACE_NAME = basename(process.cwd())
export const DATABASE_URL = process.env.DATABASE_URL

export function log(...msg) {
  console.log(magentaBright('>'), inverse(magentaBright(bold(` NXPM `))), gray(`${WORKSPACE_NAME}`), ...msg)
}

export async function connectToPostgres(url: string): Promise<Client> {
  const client = new Client(url)
  await client.connect()
  return client
}

export async function canConnect(url: string): Promise<boolean> {
  try {
    await connectToPostgres(url)
    log(`✅  Connected to Postgres`)
    return true
  } catch (e) {
    return false
  }
}

export function ensureDockerIsRunning() {
  try {
    execSync('docker ps', { stdio: 'ignore' })
    log('✅  Docker is Up')
    return true
  } catch (e) {
    throw new Error(`❌  Make sure Docker is running`)
  }
}

export function isDockerComposeRunning(): boolean {
  try {
    const res = execSync('docker-compose top', { stdio: ['inherit', 'inherit'] })

    if (res) {
      log('✅ Docker Compose is Running')
      return true
    }
    console.log('res', res)
    return false
  } catch (e) {
    return false
  }
}

export async function ensureDockerComposeIsRunning() {
  const isRunning = await isDockerComposeRunning()
  if (isRunning) {
    console.log('isRunning ')
    return true
  }

  try {
    log('✅ Docker Compose Starting')
    execSync('docker-compose up -d', { stdio: 'ignore' })

    await waitForConnection()
  } catch (e) {
    throw new Error(`Make sure Docker Compose is running`)
  }
}

export function ensureDotEnv() {
  try {
    if (!existsSync('.env')) {
      writeFileSync('.env', readFileSync('.env.example'))
      log('✅  .env created (copied from .env.example)')
    } else {
      log('✅  .env exists')
    }
  } catch (e) {
    throw new Error(`Make sure Docker Compose is running`)
  }
}

export function runPrismaSetup() {
  try {
    execSync('yarn prisma:db-push', { stdio: 'ignore' })
    log('✅  Prisma Setup is Done')
    return true
  } catch (e) {
    throw new Error(`There was an issue running 'yarn prisma:db-push'`)
  }
}

export function runPrismaSeed() {
  try {
    execSync('yarn prisma:seed --confirm --timeout 0', { stdio: 'ignore' })
    log('✅  Prisma Seed is Done')
    return true
  } catch (e) {
    throw new Error(`There was an issue running 'yarn prisma:seed'`)
  }
}

export const sleep = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms))

async function waitForConnection(): Promise<any> {
  log('Waiting for Postgres to connect')
  return new Promise(async (resolve, reject) => {
    let count = 0
    let connected = false

    while (!connected && count < MAX_RETRIES) {
      process.stdout.write('.')
      // console.log('LOOP ' + count)
      connected = await canConnect(DATABASE_URL)
      await sleep()
      count++
    }

    if (connected) {
      return resolve()
    }
    return reject()
  })
}
